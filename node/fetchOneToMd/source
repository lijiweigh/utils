<div class="content content_style" data-v-61d5a382=""><div data-v-61d5a382=""><h2 id="articleHeader0">1 nextTick的使用</h2><p>vue中dom的更像并不是实时的，当数据改变后，vue会把渲染<strong>watcher</strong>添加到异步队列，异步执行，同步代码执行完成后再统一修改dom，我们看下面的代码。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>{{msg}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

export default {
  name: 'index',
  data () {
    return {
      msg: 'hello'
    }
  },
  mounted () {
    this.msg = 'world'
    let box = document.getElementsByClassName('box')[0]
    console.log(box.innerHTML) // hello
  }
}</code></pre><p>可以看到，<strong>修改数据</strong>后并不会<strong>立即更新dom</strong>&nbsp;，dom的更新是<strong>异步</strong>的，无法通过同步代码获取，需要使用<strong>nextTick</strong>，在下一次事件循环中获取。</p><pre><code class="hljs javascript"><span class="hljs-keyword">this</span>.msg = <span class="hljs-string">'world'</span>
<span class="hljs-keyword">let</span> box = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">'box'</span>)[<span class="hljs-number">0</span>]
<span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(box.innerHTML) <span class="hljs-comment">// world</span>
})</code></pre><p>如果我们需要获取数据更新后的dom信息，比如动态获取宽高、位置信息等，需要使用nextTick。</p><p><br></p><h2 id="articleHeader1">2 数据变化dom更新与nextTick的原理分析</h2><h3 id="articleHeader2">2.1 数据变化</h3><p>vue双向数据绑定依赖于ES5的<strong>Object.defineProperty</strong>，在数据初始化的时候，通过Object.defineProperty为每一个属性创建<strong>getter</strong>与<strong>setter</strong>，把数据变成响应式数据。对属性值进行修改操作时，如this.msg = world，实际上会触发<strong>setter</strong>。下面看源码，为方便越读，源码有删减。</p><p><img src="http://api.fly63.com/vue_blog/public/Uploads/20190812/5d516dd5df278.jpg" style="max-width:100%;"><br></p><p>数据改变触发<strong>set</strong>函数</p><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(obj, key, {
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-comment">// 数据修改后触发set函数 经过一系列操作 完成dom更新</span>
  set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>{
    <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val
    <span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">if</span> (setter) {
      setter.call(obj, newVal)
    } <span class="hljs-keyword">else</span> {
      val = newVal
    }
    childOb = !shallow &amp;&amp; observe(newVal)
    dep.notify() <span class="hljs-comment">// 执行dep notify方法</span>
  }
})</code></pre><p>执行<strong>dep.notify</strong>方法</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>{
  <span class="hljs-keyword">constructor</span> () {
    <span class="hljs-keyword">this</span>.id = uid++
    <span class="hljs-keyword">this</span>.subs = []
  }
  notify () {
    <span class="hljs-keyword">const</span> subs = <span class="hljs-keyword">this</span>.subs.slice()
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) {
      <span class="hljs-comment">// 实际上遍历执行了subs数组中元素的update方法</span>
      subs[i].update()
    }
  }
}</code></pre><p>当数据被引用时，如&lt;div&gt;{{msg}}&lt;/div&gt;&nbsp;，会执行get方法，并向<strong>subs</strong>数组中添加渲染<strong>Watcher</strong>，当数据被改变时执行Watcher的<strong>update</strong>方法执行数据更新。</p><pre><code class="hljs javascript">update () {
  <span class="hljs-comment">/* istanbul ignore else */</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lazy) {
    <span class="hljs-keyword">this</span>.dirty = <span class="hljs-literal">true</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sync) {
    <span class="hljs-keyword">this</span>.run()
  } <span class="hljs-keyword">else</span> {
    queueWatcher(<span class="hljs-keyword">this</span>) <span class="hljs-comment">//执行queueWatcher</span>
  }
}</code></pre><p>update 方法最终执行<strong>queueWatcher</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueWatcher</span> (<span class="hljs-params">watcher: Watcher</span>) </span>{
  <span class="hljs-keyword">const</span> id = watcher.id
  <span class="hljs-keyword">if</span> (has[id] == <span class="hljs-literal">null</span>) {
    has[id] = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">if</span> (!flushing) {
      queue.push(watcher)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// if already flushing, splice the watcher based on its id</span>
      <span class="hljs-comment">// if already past its id, it will be run next immediately.</span>
      <span class="hljs-keyword">let</span> i = queue.length - <span class="hljs-number">1</span>
      <span class="hljs-keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {
        i--
      }
      queue.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, watcher)
    }
    <span class="hljs-comment">// queue the flush</span>
    <span class="hljs-keyword">if</span> (!waiting) {
      <span class="hljs-comment">// 通过waiting 保证nextTick只执行一次</span>
      waiting = <span class="hljs-literal">true</span>
      <span class="hljs-comment">// 最终queueWatcher 方法会把flushSchedulerQueue 传入到nextTick中执行</span>
      nextTick(flushSchedulerQueue)
    }
  }
}</code></pre><p>执行<strong>flushSchedulerQueue</strong>方法</p><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSchedulerQueue</span> <span class="hljs-params">()</span> </span>{
  currentFlushTimestamp = getNow()
  flushing = <span class="hljs-keyword">true</span>
  let watcher, id
  ...
  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; queue.length; index++) {
    watcher = queue[index]
    <span class="hljs-keyword">if</span> (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = <span class="hljs-keyword">null</span>
    <span class="hljs-comment">// 遍历执行渲染watcher的run方法 完成视图更新</span>
    watcher.run()
  }
  <span class="hljs-comment">// 重置waiting变量 </span>
  resetSchedulerState()
  ...
}</code></pre><p>也就是说当数据变化最终会把<strong>flushSchedulerQueue</strong>传入到<strong>nextTick</strong>中执行flushSchedulerQueue函数会遍历执行<strong>watcher.run()</strong>方法，watcher.run()方法最终会完成视图更新，接下来我们看关键的<strong>nextTick</strong>方法到底是啥</p><h3 id="articleHeader3">2.2 nextTick</h3><p>nextTick方法会被传进来的回调push进<strong>callbacks</strong>数组，然后执行<strong>timerFunc</strong>方法</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextTick</span> (<span class="hljs-params">cb?: Function, ctx?: Object</span>) </span>{
  <span class="hljs-keyword">let</span> _resolve
  <span class="hljs-comment">// push进callbacks数组</span>
  callbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
     cb.call(ctx)
  })
  <span class="hljs-keyword">if</span> (!pending) {
    pending = <span class="hljs-literal">true</span>
    <span class="hljs-comment">// 执行timerFunc方法</span>
    timerFunc()
  }
}</code></pre><p><strong>timerFunc</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> timerFunc
<span class="hljs-comment">// 判断是否原生支持Promise</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) {
  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve()
  timerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// 如果原生支持Promise 用Promise执行flushCallbacks</span>
    p.then(flushCallbacks)
    <span class="hljs-keyword">if</span> (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = <span class="hljs-literal">true</span>
<span class="hljs-comment">// 判断是否原生支持MutationObserver</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">'undefined'</span> &amp;&amp; (
  isNative(MutationObserver) ||
  <span class="hljs-comment">// PhantomJS and iOS 7.x</span>
  MutationObserver.toString() === <span class="hljs-string">'[object MutationObserverConstructor]'</span>
)) {
  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span>
  <span class="hljs-comment">// 如果原生支持MutationObserver 用MutationObserver执行flushCallbacks</span>
  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(flushCallbacks)
  <span class="hljs-keyword">const</span> textNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-built_in">String</span>(counter))
  observer.observe(textNode, {
    <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span>
  })
  timerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>
    textNode.data = <span class="hljs-built_in">String</span>(counter)
  }
  isUsingMicroTask = <span class="hljs-literal">true</span>
<span class="hljs-comment">// 判断是否原生支持setImmediate </span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(setImmediate)) {
  timerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// 如果原生支持setImmediate  用setImmediate执行flushCallbacks</span>
    setImmediate(flushCallbacks)
  }
<span class="hljs-comment">// 都不支持的情况下使用setTimeout 0</span>
} <span class="hljs-keyword">else</span> {
  timerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// 使用setTimeout执行flushCallbacks</span>
    setTimeout(flushCallbacks, <span class="hljs-number">0</span>)
  }
}

<span class="hljs-comment">// flushCallbacks 最终执行nextTick 方法传进来的回调函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushCallbacks</span> (<span class="hljs-params"></span>) </span>{
  pending = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">const</span> copies = callbacks.slice(<span class="hljs-number">0</span>)
  callbacks.length = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; copies.length; i++) {
    copies[i]()
  }
}</code></pre><p>nextTick会优先使用<strong>microTask</strong>, 其次是<strong>macroTask</strong>&nbsp;。</p><p>也就是说nextTick中的任务，实际上会异步执行，<strong>nextTick(callback)</strong>类似于<br><strong>Promise.resolve().then(callback)</strong>，或者<strong>setTimeout(callback, 0)</strong>。</p><p>也就是说vue的视图更新&nbsp;<strong>nextTick(flushSchedulerQueue)</strong>等同于<strong>setTimeout(flushSchedulerQueue, 0)</strong>，会异步执行flushSchedulerQueue函数，所以我们在this.msg = hello 并不会立即更新dom。</p><p>要想在dom更新后读取dom信息，我们需要在<strong>本次异步任务创建之后创建一个异步任务</strong>。</p><p><img src="http://api.fly63.com/vue_blog/public/Uploads/20190812/5d516de2d8656.jpg" style="max-width:100%;"><br></p><p>为了验证这个想法我们不用nextTick，直接用<strong>setTimeout</strong>实验一下。如下面代码，验证了我们的想法。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>{{msg}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'index'</span>,
  data () {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">msg</span>: <span class="hljs-string">'hello'</span>
    }
  },
  mounted () {
    <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">'world'</span>
    <span class="hljs-keyword">let</span> box = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">'box'</span>)[<span class="hljs-number">0</span>]
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(box.innerHTML) <span class="hljs-comment">// world</span>
    })
  }
}</span></code></pre><p>如果我们在数据修改前nextTick ，那么我们添加的异步任务会在渲染的异步任务<strong>之前</strong>执行，拿不到更新后的dom。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>{{msg}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'index'</span>,
  data () {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">msg</span>: <span class="hljs-string">'hello'</span>
    }
  },
  mounted () {
    <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(box.innerHTML) <span class="hljs-comment">// hello</span>
    })
    <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">'world'</span>
    <span class="hljs-keyword">let</span> box = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">'box'</span>)[<span class="hljs-number">0</span>]
  }
}</span></code></pre><p><br></p><h2 id="articleHeader4">3 总结</h2><p>vue为了保证性能，会把dom修改添加到异步任务，所有同步代码执行完成后再统一修改dom，<strong>一次事件循环中</strong>的多次数据修改只会触发一次watcher.run()。也就是通过nextTick，nextTick会优先使用microTask创建异步任务。vue项目中如果需要获取修改后的dom信息，需要通过nextTick在dom更新任务之后创建一个异步任务。如官网所说，nextTick会在下次 DOM 更新循环结束之后执行延迟回调。</p><p><br></p><style>.tj_box{box-sizing: border-box;margin: 5px auto;width: 100%;border: 1px solid #ddd;border-radius: 5px;padding-bottom: 10px;}.tj_box .tj_tit{background: #FF5E52;display: inline-block;padding: 5px 15px;color:#fff;margin: 10px;margin-top: 0;}.tj_box .tj_li{margin:0 10px;padding: 8px 0; overflow: hidden;border-bottom: 1px dotted #ddd;}.tj_box .tj_li p{font-size: 14px;color:#666;margin: 0;line-height: 20px;}.tj_box .tj_li a{display: inline-block;color:#FF5E52;cursor: pointer;margin-left: 5px;font-weight: bold;}</style><div class="tj_box"><span class="tj_tit">站长推荐</span><div class="tj_li"><p>1.阿里云: 本站目前使用的是阿里云主机，安全/可靠/稳定。点击领取2000元代金券、了解最新阿里云产品的各种优惠活动<a target="_blank" href="http://www.fly63.com/nav/2907">点击进入</a></p></div><div class="tj_li"><p>2.腾讯云: 提供云服务器、云数据库、云存储、视频与CDN、域名等服务。腾讯云各类产品的最新活动，优惠券领取<a target="_blank" href="http://www.fly63.com/nav/2908">点击进入</a></p></div><div class="tj_li" style="border-bottom:0;"><p>3.广告联盟: 整理了目前主流的广告联盟平台，如果你有流量，可以作为参考选择适合你的平台<a target="_blank" href="http://www.fly63.com/article/detial/1460">点击进入</a></p></div></div><p>链接: <a href="http://www.fly63.com/article/detial/4657" target="_self">http://www.fly63.com/article/detial/4657</a></p><p></p></div></div>